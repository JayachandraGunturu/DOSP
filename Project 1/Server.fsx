# time "on"
#r "nuget: Akka.FSharp" 
#r "nuget: Akka.Remote"
open System
open Akka.Actor
open Akka.Configuration
open Akka.FSharp

let mutable k = 0 |> int
let mutable hashArr = [|""|]
let mutable tokenArr = [|""|]
let remotePort = "9090"
let getReq = "GetK"
let configuration = 
    ConfigurationFactory.ParseString(
        @"akka {
            stdout-loglevel : OFF
            loglevel : OFF
            actor {
                provider = ""Akka.Remote.RemoteActorRefProvider, Akka.Remote""
                
            }
            remote {
                helios.tcp {
                    port = 9090
                    hostname = 192.168.0.86
                }
            }
        }")

let system = ActorSystem.Create("server", configuration)

type ActorMsg =
    | Done of string * string
    | StartWorkers of int
    | NotDone of string
type WorkerMsg =
    |NoRemoteWorker of int

let randomStr n =
    let rand = Random()
    let chars = "ABCDEFGHIJKLMNOPQRSTUVWUXYZ0123456789"
    let charsLen = chars.Length
    let randomChars = [|for i in 0..n -> chars.[rand.Next(charsLen)]|]
    let randomString= String(randomChars)
    randomString

let sha256: string -> string =
    let byteToHex: byte -> string = fun b -> b.ToString("x2")

    let bytesToHex: byte array -> string =
        fun bytes ->
            bytes
            |> Array.fold (fun a x -> a + (byteToHex x)) ""

    let utf8ToBytes: string -> byte array = System.Text.Encoding.UTF8.GetBytes

    let tosha256: byte array -> byte array =
        fun bytes ->
            use sha256 =
                System.Security.Cryptography.SHA256.Create()

            sha256.ComputeHash(buffer = bytes)

    fun utf8 -> utf8 |> (utf8ToBytes >> tosha256 >> bytesToHex)


let generateHashes (mailbox:Actor<_>)=
    let rec loop()=actor{
        let! msg = mailbox.Receive()
        let k = int(msg)
        let mutable flag = true
        let str = "sirrinki;" + randomStr 8
        let encoded = str |> sha256
        for i in 0..k-1 do
            if(encoded.[i] <> '0') then 
                flag <- false
        if flag then
            mailbox.Context.Sender <! Done (encoded,str)
        else
            mailbox.Context.Sender <! NotDone (k.ToString())
        return! loop ()
    }
    loop()


let serverWorkers (mailbox: Actor<_>) = 
    let rec loop () = actor {
        let! msg = mailbox.Receive ()
        match msg with 
            | Done (hashVal, tkn)  ->  hashArr <- Array.append hashArr [|hashVal|]
                                       tokenArr <- Array.append tokenArr [|tkn|]
                                       mailbox.Context.Sender <! k

            | StartWorkers numberOfZeros ->    let workersList=[for i in 1..10 do yield(spawn system ("WorkerID" + i.ToString())) generateHashes]                                                                  
                                               let workerBroadCaster = system.ActorOf(Props.Empty.WithRouter(Akka.Routing.BroadcastGroup(workersList)))
                                               workerBroadCaster <! numberOfZeros
                                               printfn "Server worker started to mine hashes...................."
            
            | NotDone msg ->   mailbox.Context.Sender <! k
        return! loop ()
    }
    loop ()

let startWorker = 
    spawn system "startWorker"
    <| fun mailbox ->
        let rec loop() =
            actor {
                let! msg = mailbox.Receive()
                match msg with
                | NoRemoteWorker k -> let workersRef = spawn system "Workers" serverWorkers
                                      workersRef <! StartWorkers k
                return! loop() 
            }
        loop()


let getRemoteWorker ip = 
    let addr = "akka.tcp://RemoteWorker@" + ip + ":" + remotePort + "/user/" + "getInputFromServer"
    let actorref = system.ActorSelection(addr)
    actorref


let requestHandler = 
     spawn system "requestHandler"
    <| fun mailbox ->
        let rec loop() =
            actor {
                let! msg = mailbox.Receive()
                let arr = msg.ToString().Split ","
                let req = arr.[0].ToString()
                let ipOrToken = arr.[1].ToString()
                let remoteWorkerRef = getRemoteWorker ipOrToken                
                if(req.CompareTo(getReq)=0) then
                    printfn "Remote Worker with IP %s started mining for desired leading zero hashes" ipOrToken
                    remoteWorkerRef <! k.ToString()
                else
                    let len = hashArr.Length-1
                    printfn ("----------------Hashes mined by client----------------")
                    printfn "IP Adress of client : %s" arr.[2]
                    printfn "Token generated by client: %s" req
                    printfn "Hash generated by client: %s" ipOrToken
                    if(len=0) then
                        printfn ("Hash found by the client faster than the server")
                    else
                        printfn ("----------------Hashes mined by server----------------")
                        for i in 0..hashArr.Length-1 do
                             printf "Token : %s" tokenArr.[i]
                             printfn " Hash : %s" hashArr.[i]
                        
                    mailbox.Context.Self.Tell(PoisonPill.Instance, mailbox.Self)
                    mailbox.Context.Stop(mailbox.Context.Self) |> ignore
                    mailbox.Context.Stop(mailbox.Context.Parent) |> ignore
                    system.Terminate() |> ignore

                return! loop() 
            }
        loop()

k <- (fsi.CommandLineArgs.[1]) |> int

startWorker <! NoRemoteWorker k

system.WhenTerminated.Wait()        